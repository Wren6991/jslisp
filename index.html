<!DOCTYPE html>
<html>
<head>
<title>LISP</title>
<link rel="stylesheet" type="text/css" href="./style.css">
<script type="text/javascript">

var t_type = {
	eof:		0,
	lparen:		1,
	rparen:		2,
	number:		3,
	symbol:		4,
	string: 	5 
};

var state = {
	start:	0,
	number: 1,
	symbol:	2,
	string: 3
};

var vars = {};

var forms = {
	PRINT:	true,
	CAR:	true,
	CDR:	true,
	CONS:	true,
	LAMBDA:	true,
	"IF":	true,
	LET:	true,
	DEFUN:	true,
	EVAL:	true,
	QUOTE:	true,
	REM:	true,
	"AND":	true,
	"OR":	true,
	"NOT":	true,
	"+":	true,
	"-":	true,
	"*":	true,
	"/":	true,
	"<":	true, 
	">":	true, 
	"<=":	true, 
	">=":	true,
	"=":	true
};
	

function list(car, cdr)
{
	this.car = car;
	this.cdr = cdr;
	return this;
}

function token(type, value)
{
	this.type = type;
	this.value = value;
	return this;
}

function lfunc(varnames, expression)
{
	this.isFunction = true;
	this.varnames = varnames;
	this.expression = expression;
}

function tokenize(progstring)
{
	var length = progstring.length;
	var pos = 0;
	var regionstart = 0;
	var v;
	var tokens = [];
	var s = 0;

	var operators = {
		"+":	true, 
		"-":	true, 
		"*":	true, 
		"/":	true, 
		"<":	true, 
		">":	true, 
		"<=":	true, 
		">=":	true,
		"=":	true 
	}; 

	while(pos < length)
	{
		v = progstring.charCodeAt(pos);
		
		switch(s)
		{
			case state.start:
				regionstart = pos;
				if (v == "(".charCodeAt(0))
					tokens.push(new token(t_type.lparen, "("));
				else if (v == ")".charCodeAt(0))
					tokens.push(new token(t_type.rparen, ")"));
				else if (operators[String.fromCharCode(v)])
					tokens.push(new token(t_type.symbol, String.fromCharCode(v)));
				else if (v == "\"".charCodeAt(0))
					s = state.string;
				else if (v >= 48 && v <= 57)					// digits 0 to 9
				{
					s = state.number;
				}
				else if ((v >= "a".charCodeAt(0) && v <= "z".charCodeAt(0)) || v == "_".charCodeAt(0))
				{
					s = state.symbol;
 				}
				break;
			case state.number:
				if (v < 48 || v > 57)						// not a digit
				{ 
					tokens.push(new token(t_type.number, progstring.substring(regionstart, pos)));
					s = state.start
					pos--;
				}
				break;
			case state.symbol:
				if (!((v >= "a".charCodeAt(0) && v <= "z".charCodeAt(0)) || v == "_".charCodeAt(0)))	//not a lower case letter or an underscore
				{
					tokens.push(new token(t_type.symbol, progstring.substring(regionstart, pos)));
					s = state.start
					pos--;							//decrement the position so the same character gets read again in the start state next cycle
				}
				break;
			case state.string:
				if (v == "\"".charCodeAt(0))
				{
					tokens.push(new token(t_type.string, progstring.substring(regionstart + 1, pos)))
					s = state.start;
				}
				break;
		}
		pos++;
	}
	return tokens;
	
}


function parse(tokens)
{
	var index = 0;
	var t = tokens[0];
	var ntokens = tokens.length;
	var lastt;
	var rootnode
	function accept(type)
	{
		if (index < ntokens && t.type == type)
		{
			lastt = t;
			index++;
			t = tokens[index];
			return true;
		}
		else
			return false;
	}

	function expect(type)
	{
		if (index >= ntokens)
		{
			alert("used ALL the tokens (expecting a " + type + ")");
			return false;
		}
		if (!accept(type))
		{
			alert("Error: expected " + type + " near " + t.value);
			return false;
		}
		else
		{
			return true;
		}
	}

	function readlist()
	{
		var head = new list();
		var tail = head;
		while (accept(t_type.symbol) || accept(t_type.number) || accept(t_type.lparen) || accept(t_type.string))
		{
			switch(lastt.type)
			{
				case t_type.symbol:
					if (lastt.value == "true")
						tail.car = true;
					else if (lastt.value == "false")
						tail.car = false;
					else
					{
						tail.car = new String(lastt.value.toUpperCase());
						tail.car.isSymbol = true;
					}
					break;
				case t_type.string:
					tail.car = lastt.value;
					break;
				case t_type.number:
					tail.car = parseFloat(lastt.value);
					break;
				case t_type.lparen:
					tail.car = readlist();
					break;
			}
			tail.cdr = new list();
			tail = tail.cdr;


		}
		expect(t_type.rparen);
		return head;
	}

	if (accept(t_type.lparen))
	{
		rootnode = readlist();
	}
	else
	{
		rootnode = t.value;
	}
	return rootnode;
}


/*function evaluate(expression)
{
	var temp = evaluate_(expression);
	//alert("returned " + temp + " (" + typeof(temp) + ")");
	return temp;
}*/

function evaluate(expression)
{
	if (typeof(expression) == "number" || typeof(expression) == "boolean" || typeof(expression) == "string")
		return expression;
	
	//Symbols are of type object, so that the isSymbol tag can be added.

	if (expression.isSymbol)
	{
		if (forms[expression])
			return expression;
		else
			return vars[expression];
	}

	if (!expression.car)
		return false;

	// ^ after this point, we can be certain that the expression is a list with at least one value.


	var car = evaluate(expression.car);

	if (car.isFunction)
	{
		var temps = {};
		var name_iter = car.varnames;
		var arg_iter = expression.cdr;
		while (name_iter.car && arg_iter.car)
		{
			temps[name_iter.car] = vars[name_iter.car];
			vars[name_iter.car] = evaluate(arg_iter.car);
			name_iter = name_iter.cdr;
			arg_iter = arg_iter.cdr;
		}
		var result = evaluate(car.expression);
		for (name in temps)
		{
			vars[name] = temps[name];
		}
		return result;
	}
	
	switch(String(car))
	{
		case "PRINT":
		{
			var result = evaluate(expression.cdr.car);
			document.getElementsByName("Output")[0].value += "Printed: " + result + "\n";
			return result;
		}
		case "LIST":
			return expression.cdr;		//no evaluation - we just return the list.
		case "CAR":
			return evaluate(evaluate(expression.cdr.car).car);
		case "CDR":
			return evaluate(expression.cdr.car).cdr;
		case "CONS":
			return new list(evaluate(expression.cdr.car), evaluate(expression.cdr.cdr.car));
		case "LAMBDA":
			return new lfunc(expression.cdr.car, expression.cdr.cdr.car);
		case "LET":
			vars[expression.cdr.car] = evaluate(expression.cdr.cdr.car);
			return vars[expression.cdr.car];
		case "DEFUN":
			vars[expression.cdr.car] = new lfunc(expression.cdr.cdr.car, expression.cdr.cdr.cdr.car);
			return vars[expression.cdr.car];
		case "IF":
			if(evaluate(expression.cdr.car))
				return evaluate(expression.cdr.cdr.car);
			else
				return evaluate(expression.cdr.cdr.cdr.car);
		case "QUOTE":
			return expression.cdr.car;
		case "REM":
			return evaluate(expression.cdr.car) % evaluate(expression.cdr.cdr.car);
		case "NOT":
			return !evaluate(expression.cdr.car);
		case "AND":
			return evaluate(expression.cdr.car) && evaluate(expression.cdr.cdr.car);
		case "OR":
			return evaluate(expression.cdr.car) || evaluate(expression.cdr.cdr.car);
		case "EVAL":
		{
			var iter = expression.cdr;
			var result;
			while (iter.car)
			{
				result = evaluate(iter.car);
				iter = iter.cdr;
			}
			return result;
		}
		case "+":
		{
			var tail = expression.cdr;
			var total = evaluate(tail.car);
			tail = tail.cdr;
			while (tail.car)
			{
				total += evaluate(tail.car);
				tail = tail.cdr;
			}
			return total;
		}
		case "-":
		{
			var tail = expression.cdr;
			var total = evaluate(tail.car);
			tail = tail.cdr;
			while (tail.car)
			{
				total -= evaluate(tail.car);
				tail = tail.cdr;
			}
			return total;
		}
		case "*":
		{
			var tail = expression.cdr;
			var total = evaluate(tail.car);
			tail = tail.cdr;
			while (tail.car)
			{
				total = total * evaluate(tail.car);
				tail = tail.cdr;
			}
			return total;
		}
		case "/":
		{
			var tail = expression.cdr;
			var total = evaluate(tail.car);
			tail = tail.cdr;
			while (tail.car)
			{
				total = total / evaluate(tail.car);
				tail = tail.cdr;
			}
			return total;
		}
		case "<":
			return evaluate(expression.cdr.car) < evaluate(expression.cdr.cdr.car);
		case ">":
			return evaluate(expression.cdr.car) > evaluate(expression.cdr.cdr.car);
		case "<=":
			return evaluate(expression.cdr.car) <= evaluate(expression.cdr.cdr.car);
		case ">=":
			return evaluate(expression.cdr.car) >= evaluate(expression.cdr.cdr.car);
		case "=":
			return evaluate(expression.cdr.car) == evaluate(expression.cdr.cdr.car);
		default:
			alert("Undefined form: " + expression.car);
			return false;
	}
}

function execute()
{

	var progstring = document.getElementsByName("Prog")[0].value;
	var tokens = tokenize(progstring); 	

	var prog = parse(tokens);

	var output = evaluate(prog);

	document.getElementsByName("Output")[0].value += "==> " + output + "\n";
}

</script>
</head>

<body>
<p>JSLisp</p>
<textarea name="Prog" rows=10 cols=80>((lambda (f a) (f f a)) (lambda (f n) (if (> n 1) (* n (f f (- n 1))) 1)) 5)</textarea>
<br/>
<input type=button name="btnExecute" onclick="execute();" value="Run" width=500px>
<br/>
<textarea name="Output" rows=5 cols=80></textarea>
</body>
</html>